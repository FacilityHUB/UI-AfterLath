local Configuration = {
    -- Checks
    TeamCheck = false,
    WallCheck = false,
    AliveCheck = false,
    FovCheck = false,

    -- FOV Settings
    Fov = false,
    Visible = false,
    Thickness = 0.6,
    Color = Color3.fromRGB(255, 255, 255),
    LockColor = Color3.fromRGB(255, 0, 0),
    OffColor = Color3.fromRGB(150, 150, 150),
    Filled = false,
    Size = 100,
    FOV = nil,  -- Expose FOV object

    -- Aimbot Settings
    SelectedPart = { "Head" },
    maxDistance = 2000,
    sensitivity = 0.1,
    AimBotEnabled = false,
    aimbotActive = false,
    AimToggleMode = false,
    AimKey = Enum.UserInputType.MouseButton2,
    Priority = "Cursor",
    aimpredictions = false,
    predictionTime = 0.1
}

local function findTargetPart(player, targetPartName)
    if not player.Character or not targetPartName then
        return nil
    end

    for _, descendant in ipairs(player.Character:GetDescendants()) do
        if descendant:IsA("BasePart") and descendant.Name == targetPartName then
            return descendant
        end
    end
    return nil
end

local function predictPosition(targetPart)
    if not targetPart or not targetPart:IsA("BasePart") then
        return nil
    end
    if Configuration.aimpredictions then
        return targetPart.Position + targetPart.Velocity * Configuration.predictionTime
    end
    return targetPart.Position
end

local function alignCameraToTarget(targetPosition)
    workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, targetPosition)
end

local function isInFOV(targetPosition)
    local Cam = workspace.CurrentCamera
    local screenPosition, isVisible = Cam:WorldToViewportPoint(targetPosition)
    local distanceFromCenter = (Vector2.new(screenPosition.X, screenPosition.Y) - Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)).Magnitude
    return isVisible and distanceFromCenter <= Configuration.Size
end

local function isValidTarget(player, part)
    local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if not part or not humanoid or humanoid.Health <= 0 then return false end

    if Configuration.TeamCheck then
        local localFaction = game.Players.LocalPlayer:FindFirstChild("PersonalFactionData")
            and game.Players.LocalPlayer.PersonalFactionData:FindFirstChild("PersonalFaction")
        local targetFaction = player:FindFirstChild("PersonalFactionData")
            and player.PersonalFactionData:FindFirstChild("PersonalFaction")
        if localFaction and targetFaction and localFaction.Value == targetFaction.Value then
            return false
        end
    end

    if Configuration.WallCheck then
        local ray = workspace:FindPartOnRayWithIgnoreList(
            Ray.new(workspace.CurrentCamera.CFrame.Position, (part.Position - workspace.CurrentCamera.CFrame.Position).Unit * Configuration.maxDistance),
            { game.Players.LocalPlayer.Character, workspace.CurrentCamera }
        )
        if not ray or not ray:IsDescendantOf(player.Character) then
            return false
        end
    end

    if Configuration.FovCheck and not isInFOV(part.Position) then
        return false
    end

    return true
end

local function getClosestPlayer(trg_part)
    local nearest = nil
    local lastDistance = Configuration.maxDistance
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            local part = findTargetPart(player, trg_part)
            if part and isValidTarget(player, part) then
                local distance = (workspace.CurrentCamera.CFrame.Position - part.Position).Magnitude
                if distance < lastDistance then
                    nearest = player
                    lastDistance = distance
                end
            end
        end
    end
    return nearest
end

local function getLowestHealthPlayer(trg_part)
    local target = nil
    local lowestHealth = math.huge
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            local part = findTargetPart(player, trg_part)
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if part and humanoid and humanoid.Health > 0 and isValidTarget(player, part) then
                if humanoid.Health < lowestHealth then
                    target = player
                    lowestHealth = humanoid.Health
                end
            end
        end
    end
    return target
end

local function getPlayerClosestToCursor(trg_part)
    local nearest = nil
    local smallestDistance = math.huge
    local mousePosition = Vector2.new(Mouse.X, Mouse.Y)
    local Cam = workspace.CurrentCamera

    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            local part = findTargetPart(player, trg_part)
            if part and isValidTarget(player, part) then
                local screenPosition, isVisible = Cam:WorldToViewportPoint(part.Position)
                local distanceToCursor = (Vector2.new(screenPosition.X, screenPosition.Y) - mousePosition).Magnitude
                if isVisible and distanceToCursor < smallestDistance then
                    nearest = player
                    smallestDistance = distanceToCursor
                end
            end
        end
    end
    return nearest
end

function Configuration.Load()
    Configuration.FOV = Drawing.new("Circle")
    Configuration.FOV.Visible = Configuration.Visible
    Configuration.FOV.Thickness = Configuration.Thickness
    Configuration.FOV.Color = Configuration.Color
    Configuration.FOV.Filled = Configuration.Filled
    Configuration.FOV.Radius = Configuration.Size
end

return Configuration
